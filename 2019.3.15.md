###### 1.简要介绍LDA原理和PCA原理：

- LDA:监督学习的降维技术，将数据在低维度上进行投影，投影后希望每一种类别数据的投影点尽可能的接近，而不同类别的数据的类别中心之间的距离尽可能的大。“ 投影后类内方差最小，类间方差最大。”()

- PCA：数据里最主要的方面来代替原始数据,(数据压缩消除冗余和数据噪音消除等领域)降维的标准为：样本点到这个超平面的距离足够近,或者说样本点在这个超平面上的投影能尽可能的分开。

  **优点**

  **1）**仅仅需要以方差衡量信息量，不受数据集以外的因素影响。

  **2）**各主成分之间正交，可消除原始数据成分间的相互影响的因素。

  **3）**计算方法简单，主要运算是特征值分解，易于实现。

  **缺点**

  **1）**主成分各个特征维度的含义具有一定的模糊性，不如原始样本特征的解释性强。

  **2）**方差小的非主成分也可能含有对样本差异的重要信息，因降维丢弃可能对后续数据处理有影响。）

**两者相同点**

**1）**两者均可以对数据进行降维。

**2）**两者在降维时均使用了矩阵特征分解的思想。

**3）**两者都假设数据符合高斯分布。

**两者不同点**

**1）**LDA是有监督的降维方法，而PCA是无监督的降维方法

**2）**LDA降维最多降到类别数k-1的维数，而PCA没有这个限制。

**3）**LDA除了可以用于降维，还可以用于分类。

**4）**LDA选择分类性能最好的投影方向，而PCA选择样本点投影具有最大方差的方向。在某些数据分布下LDA比PCA降维较优。

###### 2.快速排序的最优情况：

在最优情况下，Partition每次都划分得很均匀，如果排序n个关键字，其递归树的深度就为 [log2n]+1（ [x] 表示不大于 x 的最大整数），即仅需递归 log2n 次，需要时间为T（n）的话，第一次Partiation应该是需要对整个数组扫描一遍，做n次比较。然后，获得的枢轴将数组一分为二，那么各自还需要T（n/2）的时间（注意是最好情况，所以平分两半）。于是不断地划分下去，就有了下面的不等式推断：

![img](http://img.blog.csdn.net/20140522095848359?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvb29oYWhhXzEyMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

这说明，在最优的情况下，快速排序算法的时间复杂度为O(nlogn)。



###### 3.数组中出现次数超过一半的数字：

思路：
　对于一个数组而言，满足题目要求的数字最多只有一个，可以采用数字相互抵消的思想。在遍历数组时，储存两个值now和count，now是当前数字，count是该数字的标记。当下一个数字与now相等时，标记count的值加1，如果不相等，则减1；当标记count的值变为0时，则将下一个数字的值用now来存储，并将count的值置为1，继续遍历完数组。
如果数组中存在出现次数超过数组长度一半的数，那遍历过后now中存储的即为这个数字；如果数组中不存在满足要求的数，最后now中也会存储一个不符合要求数值。所以，在算法的最后，要重新遍历一遍数组，对变量now中的值进行计数并判断，从而验证结果。

解法：
'''
def HalfLengthSolution(self, numbers):
        #判断极端情况
        if len(numbers) == 0:
            return 0
        #初始化记录变量now和count
        count = 1
        now = numbers[0]
        length = len(numbers)
        #遍历数组，采用抵消的方法，寻找结果
        for i in range(1,length):
            if count == 0:
                now = numbers[i]
                count += 1
            else:
                if numbers[i] == now:
                    count += 1
                else:
                    count -= 1
        #验证now中存储的值是否符合题目要求
        test = 0
        for item in numbers:
            if item == now:
                test += 1
        if test > length/2:
            return now
        else:
            return 0
'''


